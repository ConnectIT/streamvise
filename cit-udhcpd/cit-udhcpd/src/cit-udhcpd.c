
/* 

 * Copyright (c) 2009 - 2011, Andy Bierman
 * All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump 1.15-6

    module cit-udhcpd
    revision 2011-12-07

    namespace http://netconfcentral.org/ns/cit-udhcpd
    organization ConnectIT

 */

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_cb.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "status.h"
#include "cit-udhcpd.h"
#include "cit-helper.h"

/* module static variables */
static ncx_module_t *cit_udhcpd_mod;
static obj_template_t *udhcpd_obj;
static val_value_t *udhcpd_val;

/* put your static variables here */


/********************************************************************
* FUNCTION y_cit_udhcpd_udhcpd_running_edit
* 
* Edit database object callback
* Path: /udhcpd/running
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_cit_udhcpd_udhcpd_running_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_cit_udhcpd_udhcpd_running_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
	{
        	switch (editop) {
	        case OP_EDITOP_LOAD:
	            break;
	        case OP_EDITOP_MERGE:
	            break;
	        case OP_EDITOP_REPLACE:
	            break;
        	case OP_EDITOP_CREATE:
	            break;
	        case OP_EDITOP_DELETE:
	            break;
        	default:
	            res = SET_ERROR(ERR_INTERNAL_VAL);
	        }
	}
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_cit_udhcpd_udhcpd_running_edit */


/********************************************************************
* FUNCTION y_cit_udhcpd_udhcpd_interface_edit
* 
* Edit database object callback
* Path: /udhcpd/interface
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_cit_udhcpd_udhcpd_interface_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_cit_udhcpd_udhcpd_interface_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }


    /* remove the next line if curval is used */
    (void)curval;

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
	{
/*  Old code. TODO: Cleanup when all else works
		char tmp[] = "eth11";
		sprintf(tmp, "%s", VAL_STRING(newval));
		writeudhcpd("interface", tmp);		
*/
        	switch (editop) {
	        case OP_EDITOP_LOAD:
	            break;
	        case OP_EDITOP_MERGE:
	            break;
	        case OP_EDITOP_REPLACE:
	            break;
        	case OP_EDITOP_CREATE:
	            break;
	        case OP_EDITOP_DELETE:
	            break;
        	default:
	            res = SET_ERROR(ERR_INTERNAL_VAL);
	        }
	}
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_cit_udhcpd_udhcpd_interface_edit */


/********************************************************************
* FUNCTION y_cit_udhcpd_udhcpd_subnet_mask_edit
* 
* Edit database object callback
* Path: /udhcpd/subnet-mask
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_cit_udhcpd_udhcpd_subnet_mask_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_cit_udhcpd_udhcpd_subnet_mask_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }



    /* remove the next line if curval is used */
    (void)curval;

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
 	{
    //    Old code. TODO: Cleanup when all else works
    //	  writeudhcpd("option  subnet", VAL_STRING(newval));		

        	switch (editop) {
	        case OP_EDITOP_LOAD:
	            break;
	        case OP_EDITOP_MERGE:
	            break;
	        case OP_EDITOP_REPLACE:
	            break;
        	case OP_EDITOP_CREATE:
	            break;
	        case OP_EDITOP_DELETE:
	            break;
        	default:
	            res = SET_ERROR(ERR_INTERNAL_VAL);
	        }
	}
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_cit_udhcpd_udhcpd_subnet_mask_edit */


/********************************************************************
* FUNCTION y_cit_udhcpd_udhcpd_router_edit
* 
* Edit database object callback
* Path: /udhcpd/router
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_cit_udhcpd_udhcpd_router_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_cit_udhcpd_udhcpd_router_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if curval is used */
    (void)curval;

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
 	{
    //    Old code. TODO: Cleanup when all else works
    //		writeudhcpd("option  router", VAL_STRING(newval));		

        	switch (editop) {
	        case OP_EDITOP_LOAD:
	            break;
	        case OP_EDITOP_MERGE:
	            break;
	        case OP_EDITOP_REPLACE:
	            break;
        	case OP_EDITOP_CREATE:
	            break;
	        case OP_EDITOP_DELETE:
	            break;
        	default:
	            res = SET_ERROR(ERR_INTERNAL_VAL);
	        }
	}
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_cit_udhcpd_udhcpd_router_edit */


/********************************************************************
* FUNCTION y_cit_udhcpd_udhcpd_dns_server_ip_address_edit
* 
* Edit database object callback
* Path: /udhcpd/dns/server/ip-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_cit_udhcpd_udhcpd_dns_server_ip_address_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_cit_udhcpd_udhcpd_dns_server_ip_address_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if curval is used */
    (void)curval;

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
   	{
    //    Old code. TODO: Cleanup when all else works
    //		writeudhcpd("option  dns", VAL_STRING(newval));		

        	switch (editop) {
	        case OP_EDITOP_LOAD:
	            break;
	        case OP_EDITOP_MERGE:
	            break;
	        case OP_EDITOP_REPLACE:
	            break;
        	case OP_EDITOP_CREATE:
	            break;
	        case OP_EDITOP_DELETE:
	            break;
        	default:
	            res = SET_ERROR(ERR_INTERNAL_VAL);
	        }
	}
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_cit_udhcpd_udhcpd_dns_server_ip_address_edit */


/********************************************************************
* FUNCTION y_cit_udhcpd_udhcpd_dns_server_edit
* 
* Edit database object callback
* Path: /udhcpd/dns/server
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_cit_udhcpd_udhcpd_dns_server_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_cit_udhcpd_udhcpd_dns_server_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_cit_udhcpd_udhcpd_dns_server_edit */


/********************************************************************
* FUNCTION y_cit_udhcpd_udhcpd_dns_edit
* 
* Edit database object callback
* Path: /udhcpd/dns
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_cit_udhcpd_udhcpd_dns_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_cit_udhcpd_udhcpd_dns_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
 		switch (editop) {
		case OP_EDITOP_LOAD:
		    break;
		case OP_EDITOP_MERGE:
		    break;
		case OP_EDITOP_REPLACE:
		    break;
		case OP_EDITOP_CREATE:
		    break;
		case OP_EDITOP_DELETE:
		    break;
		default:
		    res = SET_ERROR(ERR_INTERNAL_VAL);
		}
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_cit_udhcpd_udhcpd_dns_edit */


/********************************************************************
* FUNCTION y_cit_udhcpd_udhcpd_hostname_edit
* 
* Edit database object callback
* Path: /udhcpd/hostname
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_cit_udhcpd_udhcpd_hostname_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_cit_udhcpd_udhcpd_hostname_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if curval is used */
    (void)curval;

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
	{
	  //    Old code. TODO: Cleanup when all else works
    //		writeudhcpd("option  hostname", VAL_STRING(newval));		

        	switch (editop) {
	        case OP_EDITOP_LOAD:
	            break;
	        case OP_EDITOP_MERGE:
	            break;
	        case OP_EDITOP_REPLACE:
	            break;
        	case OP_EDITOP_CREATE:
	            break;
	        case OP_EDITOP_DELETE:
	            break;
        	default:
	            res = SET_ERROR(ERR_INTERNAL_VAL);
	        }
	}
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_cit_udhcpd_udhcpd_hostname_edit */


/********************************************************************
* FUNCTION y_cit_udhcpd_udhcpd_lease_time_edit
* 
* Edit database object callback
* Path: /udhcpd/lease-time
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_cit_udhcpd_udhcpd_lease_time_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_cit_udhcpd_udhcpd_lease_time_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if curval is used */
    (void)curval;

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
	{
    /*  Old code. TODO: Cleanup when all else works
    		char tmp[32];
    		sprintf(tmp, "%i", VAL_UINT(newval));
    		writeudhcpd("option  lease", tmp);		
    */
        	switch (editop) {
	        case OP_EDITOP_LOAD:
	            break;
	        case OP_EDITOP_MERGE:
	            break;
	        case OP_EDITOP_REPLACE:
	            break;
        	case OP_EDITOP_CREATE:
	            break;
	        case OP_EDITOP_DELETE:
	            break;
        	default:
	            res = SET_ERROR(ERR_INTERNAL_VAL);
	        }
	}
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_cit_udhcpd_udhcpd_lease_time_edit */


/********************************************************************
* FUNCTION y_cit_udhcpd_udhcpd_static_leases_lease_mac_edit
* 
* Edit database object callback
* Path: /udhcpd/static-leases/lease/mac
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_cit_udhcpd_udhcpd_static_leases_lease_mac_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_cit_udhcpd_udhcpd_static_leases_lease_mac_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_cit_udhcpd_udhcpd_static_leases_lease_mac_edit */


/********************************************************************
* FUNCTION y_cit_udhcpd_udhcpd_static_leases_lease_ip_address_edit
* 
* Edit database object callback
* Path: /udhcpd/static-leases/lease/ip-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_cit_udhcpd_udhcpd_static_leases_lease_ip_address_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_cit_udhcpd_udhcpd_static_leases_lease_ip_address_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_cit_udhcpd_udhcpd_static_leases_lease_ip_address_edit */


/********************************************************************
* FUNCTION y_cit_udhcpd_udhcpd_static_leases_lease_edit
* 
* Edit database object callback
* Path: /udhcpd/static-leases/lease
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_cit_udhcpd_udhcpd_static_leases_lease_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_cit_udhcpd_udhcpd_static_leases_lease_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_cit_udhcpd_udhcpd_static_leases_lease_edit */


/********************************************************************
* FUNCTION y_cit_udhcpd_udhcpd_static_leases_edit
* 
* Edit database object callback
* Path: /udhcpd/static-leases
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_cit_udhcpd_udhcpd_static_leases_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_cit_udhcpd_udhcpd_static_leases_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_cit_udhcpd_udhcpd_static_leases_edit */


/********************************************************************
* FUNCTION y_cit_udhcpd_udhcpd_range_start_edit
* 
* Edit database object callback
* Path: /udhcpd/range/start
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_cit_udhcpd_udhcpd_range_start_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_cit_udhcpd_udhcpd_range_start_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }



    /* remove the next line if curval is used */
    (void)curval;

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
 	{
   	//    Old code. TODO: Cleanup when all else works
    //		writeudhcpd("start", VAL_STRING(newval));		

        	switch (editop) {
	        case OP_EDITOP_LOAD:
	            break;
	        case OP_EDITOP_MERGE:
	            break;
	        case OP_EDITOP_REPLACE:
	            break;
        	case OP_EDITOP_CREATE:
	            break;
	        case OP_EDITOP_DELETE:
	            break;
        	default:
	            res = SET_ERROR(ERR_INTERNAL_VAL);
	        }
	}
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_cit_udhcpd_udhcpd_range_start_edit */


/********************************************************************
* FUNCTION y_cit_udhcpd_udhcpd_range_end_edit
* 
* Edit database object callback
* Path: /udhcpd/range/end
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_cit_udhcpd_udhcpd_range_end_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_cit_udhcpd_udhcpd_range_end_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }


    /* remove the next line if curval is used */
    (void)curval;

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
	{
	  //    Old code. TODO: Cleanup when all else works
    //		writeudhcpd("end", VAL_INT(newval));		

        	switch (editop) {
	        case OP_EDITOP_LOAD:
	            break;
	        case OP_EDITOP_MERGE:
	            break;
	        case OP_EDITOP_REPLACE:
	            break;
        	case OP_EDITOP_CREATE:
	            break;
	        case OP_EDITOP_DELETE:
	            break;
        	default:
	            res = SET_ERROR(ERR_INTERNAL_VAL);
	        }
	}
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_cit_udhcpd_udhcpd_range_end_edit */


/********************************************************************
* FUNCTION y_cit_udhcpd_udhcpd_range_edit
* 
* Edit database object callback
* Path: /udhcpd/range
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_cit_udhcpd_udhcpd_range_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_cit_udhcpd_udhcpd_range_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_cit_udhcpd_udhcpd_range_edit */


/********************************************************************
* FUNCTION y_cit_udhcpd_udhcpd_edit
* 
* Edit database object callback
* Path: /udhcpd
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_cit_udhcpd_udhcpd_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_cit_udhcpd_udhcpd_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
	{
		printf("****    No of children: %i\n", val_child_cnt(newval));

		val_value_t *tmpval; //Will hold the data node that we're processing each time

		// Is the service up or down?
		tmpval = val_match_child(newval, "cit-udhcpd", "running"); //Find "running" in cit-udhpcd
		if (tmpval != NULL) {
			char cmd[512];
			if (VAL_BOOL(tmpval)){ //Service should be running
				printf("****    true\n"	); //TODO: change
				sprintf(cmd, "sudo service udhcpd start");
			}else{ //Service should NOT be running
				printf("****    false\n"); //TODO: change
				sprintf(cmd, "sudo service udhcpd stop");
			}
			int resultss = runsystem(cmd); //Send command for running
		}

		// Interface name
		tmpval = val_match_child(newval, "cit-udhcpd", "interface"); //Find "interface" in cit-udhcpd
		if (tmpval != NULL) {
			char iface[] = "eth11"; //Dummy interface, just used for var init
			sprintf(iface, "%s", VAL_STRING(tmpval)); //Get the value
			printf("****    Iface name: %s\n", iface);
		  writeudhcpd("interface", iface); //Write the setting to config file	
		}

		// Subnet mask
		tmpval = val_match_child(newval, "cit-udhcpd", "subnet-mask"); //Find "subnet-mask" in cit-udhpd
		if (tmpval != NULL) {		
			writeudhcpd("option  subnet", VAL_STRING(tmpval)); //Write the setting to config file	
		}

		// Router IP
		tmpval = val_match_child(newval, "cit-udhcpd", "router"); //Find "router" in cit-udhpd
		if (tmpval != NULL) {	
			writeudhcpd("option  router", VAL_STRING(tmpval)); //Write the setting to config file	
		}


		// DNS servers
		val_value_t *tmpserver; //Will hold the "server" list
		val_value_t *tmpchild; //Will hold server's children, ip-address leaf nodes
		tmpval = val_match_child(newval, "cit-udhcpd", "dns"); //Find "dns" container in cit-udhpd
		if (tmpval != NULL){
			printf("****    Dns container found\n");

			tmpserver = val_get_first_child(tmpval); //Get the first DNS server node
			while (tmpserver != NULL){ //Check if there are still DNS IP addresses!
				tmpchild = val_get_first_child(tmpserver); //Get the IP address
				printf("****    DNS: %s\n", VAL_STRING(tmpchild));
				writeudhcpd("option  dns", VAL_STRING(tmpchild)); //Write the setting to config file	
				tmpserver = val_get_next_child(tmpserver); //Get the next DNS server
			}

		}

		// Hostname
		tmpval = val_match_child(newval, "cit-udhcpd", "hostname"); //Find "hostname" in cit-udhpd
		if (tmpval != NULL) {	
  		writeudhcpd("option  hostname", VAL_STRING(tmpval)); //Write the setting to config file	
		}

		// Lease time
		tmpval = val_match_child(newval, "cit-udhcpd", "lease-time"); //Find "lease-time" in cit-udhpd
		if (tmpval != NULL) {	
			writeudhcpd("option  lease", VAL_UINT(tmpval)); //Write the setting to config file	
		}


		// Static leases
		val_value_t *tmplease; //Will hold the "lease" list
		char *MAC="FF:FF:FF:FF:FF:FF";
		char *MAC2="xxxx"; //Local variable
		char *IP="255.255.255.255";
		tmpval = val_match_child(newval, "cit-udhcpd", "static-leases"); //Find "static-leases" container in cit-udhpd
		if (tmpval != NULL){
			printf("****    Static leases container found\n");

			tmplease = val_get_first_child(tmpval); //Get the first lease node
			while (tmplease != NULL){ //While there are more lease nodes...
				tmpchild = val_get_first_child(tmplease); //Get the MAC address leaf
				MAC = VAL_STRING(tmpchild); //Get the MAC address 
				printf("****    MAC: %s\n", MAC);
				tmpchild = val_get_next_child(tmpchild); //Get the IP address leaf
				IP = VAL_STRING(tmpchild); //Get the IP address 
				printf("****    IP: %s\n", IP);
				sprintf(MAC2, "static_lease  %s", MAC); //Incorporate static_lease and MAC in local variable
	  		writeudhcpd(MAC2, IP); //Write the setting to config file	
				tmplease = val_get_next_child(tmplease); //Get the next static lease
			}

		}


		// Start IP
		tmpval = val_match_child(newval, "cit-udhcpd", "range"); //Find "range" in cit-udhpd
		if (tmpval != NULL) {	//Something has been found
			tmpchild = val_get_first_child(tmpval); //Get the first child, AKA start address
			if (tmpval != NULL) {	
				printf("****    Start ip: %s\n", VAL_STRING(tmpchild));
				writeudhcpd("start", VAL_STRING(tmpchild)); //Write the setting to config file	
			}
		// End IP
			tmpchild = val_get_next_child(tmpchild); //Get the next child, AKA end address
			if (tmpval != NULL) {	
				printf("****    End ip: %s\n", VAL_STRING(tmpchild));
				writeudhcpd("end", VAL_STRING(tmpchild)); //Write the setting to config file	
			}



	
		switch (editop) {
		case OP_EDITOP_LOAD:
			printf("****    LOAD\n");
		    break;
		case OP_EDITOP_MERGE:
			printf("****    MERGE\n");
		    break;
		case OP_EDITOP_REPLACE:
			printf("****    REPLACE\n");
		    break;
		case OP_EDITOP_CREATE:
			printf("****    CREATE\n");
		    break;
		case OP_EDITOP_DELETE:
			printf("****    DELETE\n");
		    break;
		default:
		    res = SET_ERROR(ERR_INTERNAL_VAL);
			printf("****    DEFAULT\n");
		}
	}
        if (res == NO_ERR) {
            res = agt_check_cache(
                &udhcpd_val,
                newval,
                curval,
                editop);
        }
        
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    return res;

} /* y_cit_udhcpd_udhcpd_edit */


/********************************************************************
* FUNCTION y_cit_udhcpd_init_static_vars
* 
* initialize module static variables
* 
********************************************************************/
static void
    y_cit_udhcpd_init_static_vars (void)
{
    cit_udhcpd_mod = NULL;
    udhcpd_obj = NULL;
    udhcpd_val = NULL;

    /* init your static variables here */

} /* y_cit_udhcpd_init_static_vars */


/********************************************************************
* FUNCTION y_cit_udhcpd_init
* 
* initialize the cit-udhcpd server instrumentation library
* 
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
* 
* RETURNS:
*     error status
********************************************************************/
status_t
    y_cit_udhcpd_init (
        const xmlChar *modname,
        const xmlChar *revision)
{
    agt_profile_t *agt_profile;
    status_t res;

    y_cit_udhcpd_init_static_vars();

    /* change if custom handling done */
    if (xml_strcmp(modname, y_cit_udhcpd_M_cit_udhcpd)) {
        return ERR_NCX_UNKNOWN_MODULE;
    }

    if (revision && xml_strcmp(revision, y_cit_udhcpd_R_cit_udhcpd)) {
        return ERR_NCX_WRONG_VERSION;
    }

    agt_profile = agt_get_profile();

    res = ncxmod_load_module(
        y_cit_udhcpd_M_cit_udhcpd,
        y_cit_udhcpd_R_cit_udhcpd,
        &agt_profile->agt_savedevQ,
        &cit_udhcpd_mod);
    if (res != NO_ERR) {
        return res;
    }

    udhcpd_obj = ncx_find_object(
        cit_udhcpd_mod,
        y_cit_udhcpd_N_udhcpd);
    if (cit_udhcpd_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    
    res = agt_cb_register_callback(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd",
        (const xmlChar *)"2011-12-07",
        y_cit_udhcpd_udhcpd_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/dns",
        (const xmlChar *)"2011-12-07",
        y_cit_udhcpd_udhcpd_dns_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/dns/server",
        (const xmlChar *)"2011-12-07",
        y_cit_udhcpd_udhcpd_dns_server_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/dns/server/ip-address",
        (const xmlChar *)"2011-12-07",
        y_cit_udhcpd_udhcpd_dns_server_ip_address_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/hostname",
        (const xmlChar *)"2011-12-07",
        y_cit_udhcpd_udhcpd_hostname_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/interface",
        (const xmlChar *)"2011-12-07",
        y_cit_udhcpd_udhcpd_interface_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/lease-time",
        (const xmlChar *)"2011-12-07",
        y_cit_udhcpd_udhcpd_lease_time_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/range",
        (const xmlChar *)"2011-12-07",
        y_cit_udhcpd_udhcpd_range_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/range/end",
        (const xmlChar *)"2011-12-07",
        y_cit_udhcpd_udhcpd_range_end_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/range/start",
        (const xmlChar *)"2011-12-07",
        y_cit_udhcpd_udhcpd_range_start_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/router",
        (const xmlChar *)"2011-12-07",
        y_cit_udhcpd_udhcpd_router_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/running",
        (const xmlChar *)"2011-12-07",
        y_cit_udhcpd_udhcpd_running_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/static-leases",
        (const xmlChar *)"2011-12-07",
        y_cit_udhcpd_udhcpd_static_leases_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/static-leases/lease",
        (const xmlChar *)"2011-12-07",
        y_cit_udhcpd_udhcpd_static_leases_lease_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/static-leases/lease/ip-address",
        (const xmlChar *)"2011-12-07",
        y_cit_udhcpd_udhcpd_static_leases_lease_ip_address_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/static-leases/lease/mac",
        (const xmlChar *)"2011-12-07",
        y_cit_udhcpd_udhcpd_static_leases_lease_mac_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/subnet-mask",
        (const xmlChar *)"2011-12-07",
        y_cit_udhcpd_udhcpd_subnet_mask_edit);
    if (res != NO_ERR) {
        return res;
    }

    /* put your module initialization code here */


    return res;
} /* y_cit_udhcpd_init */


/********************************************************************
* FUNCTION y_cit_udhcpd_init2
* 
* SIL init phase 2: non-config data structures
* Called after running config is loaded
* 
* RETURNS:
*     error status
********************************************************************/
status_t
    y_cit_udhcpd_init2 (void)
{
    status_t res = NO_ERR;

    udhcpd_val = agt_init_cache(
        y_cit_udhcpd_M_cit_udhcpd,
        y_cit_udhcpd_N_udhcpd,
        &res);
    if (res != NO_ERR) {
        return res;
    }

    /* put your init2 code here */

    return res;
} /* y_cit_udhcpd_init2 */


/********************************************************************
* FUNCTION y_cit_udhcpd_cleanup
*    cleanup the server instrumentation library
* 
********************************************************************/
void
    y_cit_udhcpd_cleanup (void)
{
    agt_cb_unregister_callbacks(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd");

    agt_cb_unregister_callbacks(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/dns");

    agt_cb_unregister_callbacks(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/dns/server");

    agt_cb_unregister_callbacks(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/dns/server/ip-address");

    agt_cb_unregister_callbacks(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/hostname");

    agt_cb_unregister_callbacks(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/interface");

    agt_cb_unregister_callbacks(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/lease-time");

    agt_cb_unregister_callbacks(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/range");

    agt_cb_unregister_callbacks(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/range/end");

    agt_cb_unregister_callbacks(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/range/start");

    agt_cb_unregister_callbacks(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/router");

    agt_cb_unregister_callbacks(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/running");

    agt_cb_unregister_callbacks(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/static-leases");

    agt_cb_unregister_callbacks(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/static-leases/lease");

    agt_cb_unregister_callbacks(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/static-leases/lease/ip-address");

    agt_cb_unregister_callbacks(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/static-leases/lease/mac");

    agt_cb_unregister_callbacks(
        y_cit_udhcpd_M_cit_udhcpd,
        (const xmlChar *)"/udhcpd/subnet-mask");

    /* put your cleanup code here */
    
} /* y_cit_udhcpd_cleanup */

/* END cit_udhcpd.c */
