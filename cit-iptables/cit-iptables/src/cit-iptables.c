
/* 
 * Copyright (c) 2013, Chris Mavrakis, All Rights Reserved.
 * Full license can be found in LICENSE file.

*** Generated by yangdump 2.2.1721

    Combined SIL module
    module cit-iptables
    revision 2012-01-12
    namespace http://netconfcentral.org/ns/cit-iptables
    organization ConnectIT

 */

#include <xmlstring.h>
#include <string.h>
#include "procdefs.h"
#include "agt.h"
#include "agt_cb.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "status.h"
#include "cit-iptables.h"
#include "mine.h"

/* module static variables */
static ncx_module_t *cit_iptables_mod;
static obj_template_t *iptables_obj;
static val_value_t *iptables_val;

/* put your static variables here */


/********************************************************************
* FUNCTION y_cit_iptables_init_static_vars
* 
* initialize module static variables
* 
********************************************************************/
static void y_cit_iptables_init_static_vars (void)
{
    cit_iptables_mod = NULL;
    iptables_obj = NULL;
    iptables_val = NULL;

    /* init your static variables here */

} /* y_cit_iptables_init_static_vars */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_entryno_edit
* 
* Edit database object callback
* Path: /iptables/rule/entryno
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_entryno_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_entryno_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_entryno_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_table_table_edit
* 
* Edit database object callback
* Path: /iptables/rule/table/table
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_table_table_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_table_table_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_table_table_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_table_edit
* 
* Edit database object callback
* Path: /iptables/rule/table
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_table_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_table_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_table_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_appendto_appendto_edit
* 
* Edit database object callback
* Path: /iptables/rule/appendto/appendto
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_appendto_appendto_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_appendto_appendto_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_appendto_appendto_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_appendto_edit
* 
* Edit database object callback
* Path: /iptables/rule/appendto
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_appendto_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_appendto_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_appendto_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_protocol_protocol_edit
* 
* Edit database object callback
* Path: /iptables/rule/protocol/protocol
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_protocol_protocol_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_protocol_protocol_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_protocol_protocol_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_protocol_not_edit
* 
* Edit database object callback
* Path: /iptables/rule/protocol/not
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_protocol_not_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_protocol_not_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_protocol_not_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_protocol_edit
* 
* Edit database object callback
* Path: /iptables/rule/protocol
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_protocol_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_protocol_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_protocol_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_source_ip_ip_edit
* 
* Edit database object callback
* Path: /iptables/rule/source-ip/ip
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_source_ip_ip_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_source_ip_ip_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_source_ip_ip_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_source_ip_not_edit
* 
* Edit database object callback
* Path: /iptables/rule/source-ip/not
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_source_ip_not_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_source_ip_not_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_source_ip_not_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_source_ip_edit
* 
* Edit database object callback
* Path: /iptables/rule/source-ip
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_source_ip_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_source_ip_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_source_ip_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_dest_ip_ip_edit
* 
* Edit database object callback
* Path: /iptables/rule/dest-ip/ip
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_dest_ip_ip_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_dest_ip_ip_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_dest_ip_ip_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_dest_ip_not_edit
* 
* Edit database object callback
* Path: /iptables/rule/dest-ip/not
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_dest_ip_not_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_dest_ip_not_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_dest_ip_not_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_dest_ip_edit
* 
* Edit database object callback
* Path: /iptables/rule/dest-ip
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_dest_ip_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_dest_ip_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_dest_ip_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_input_interface_interface_edit
* 
* Edit database object callback
* Path: /iptables/rule/input-interface/interface
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_input_interface_interface_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_input_interface_interface_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_input_interface_interface_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_input_interface_not_edit
* 
* Edit database object callback
* Path: /iptables/rule/input-interface/not
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_input_interface_not_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_input_interface_not_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_input_interface_not_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_input_interface_edit
* 
* Edit database object callback
* Path: /iptables/rule/input-interface
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_input_interface_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_input_interface_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_input_interface_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_output_interface_interface_edit
* 
* Edit database object callback
* Path: /iptables/rule/output-interface/interface
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_output_interface_interface_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_output_interface_interface_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_output_interface_interface_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_output_interface_not_edit
* 
* Edit database object callback
* Path: /iptables/rule/output-interface/not
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_output_interface_not_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_output_interface_not_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_output_interface_not_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_output_interface_edit
* 
* Edit database object callback
* Path: /iptables/rule/output-interface
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_output_interface_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_output_interface_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_output_interface_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_module_module_edit
* 
* Edit database object callback
* Path: /iptables/rule/module/module
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_module_module_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_module_module_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_module_module_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_module_edit
* 
* Edit database object callback
* Path: /iptables/rule/module
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_module_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_module_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_module_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_mark_options_mark_edit
* 
* Edit database object callback
* Path: /iptables/rule/mark-options/mark
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_mark_options_mark_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_mark_options_mark_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_mark_options_mark_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_mark_options_not_edit
* 
* Edit database object callback
* Path: /iptables/rule/mark-options/not
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_mark_options_not_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_mark_options_not_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_mark_options_not_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_mark_options_edit
* 
* Edit database object callback
* Path: /iptables/rule/mark-options
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_mark_options_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_mark_options_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_mark_options_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_connmark_options_connmark_options_edit
* 
* Edit database object callback
* Path: /iptables/rule/connmark-options/connmark-options
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_connmark_options_connmark_options_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_connmark_options_connmark_options_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_connmark_options_connmark_options_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_connmark_options_edit
* 
* Edit database object callback
* Path: /iptables/rule/connmark-options
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_connmark_options_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_connmark_options_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_connmark_options_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_state_options_state_edit
* 
* Edit database object callback
* Path: /iptables/rule/state-options/state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_state_options_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_state_options_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_state_options_state_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_state_options_not_edit
* 
* Edit database object callback
* Path: /iptables/rule/state-options/not
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_state_options_not_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_state_options_not_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_state_options_not_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_state_options_edit
* 
* Edit database object callback
* Path: /iptables/rule/state-options
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_state_options_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_state_options_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_state_options_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_source_port_port_edit
* 
* Edit database object callback
* Path: /iptables/rule/source-port/port
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_source_port_port_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_source_port_port_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_source_port_port_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_source_port_not_edit
* 
* Edit database object callback
* Path: /iptables/rule/source-port/not
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_source_port_not_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_source_port_not_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_source_port_not_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_source_port_edit
* 
* Edit database object callback
* Path: /iptables/rule/source-port
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_source_port_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_source_port_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_source_port_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_destination_port_port_edit
* 
* Edit database object callback
* Path: /iptables/rule/destination-port/port
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_destination_port_port_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_destination_port_port_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_destination_port_port_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_destination_port_not_edit
* 
* Edit database object callback
* Path: /iptables/rule/destination-port/not
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_destination_port_not_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_destination_port_not_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_destination_port_not_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_destination_port_edit
* 
* Edit database object callback
* Path: /iptables/rule/destination-port
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_destination_port_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_destination_port_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_destination_port_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_jump_jump_edit
* 
* Edit database object callback
* Path: /iptables/rule/jump/jump
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_jump_jump_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_jump_jump_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_jump_jump_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_jump_edit
* 
* Edit database object callback
* Path: /iptables/rule/jump
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_jump_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_jump_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_jump_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_set_mark_option_edit
* 
* Edit database object callback
* Path: /iptables/rule/set-mark-option
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_set_mark_option_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_set_mark_option_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_set_mark_option_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_snat_options_ip_edit
* 
* Edit database object callback
* Path: /iptables/rule/snat-options/ip
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_snat_options_ip_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_snat_options_ip_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_snat_options_ip_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_snat_options_ip_end_edit
* 
* Edit database object callback
* Path: /iptables/rule/snat-options/ip-end
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_snat_options_ip_end_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_snat_options_ip_end_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_snat_options_ip_end_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_snat_options_port_start_edit
* 
* Edit database object callback
* Path: /iptables/rule/snat-options/port-start
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_snat_options_port_start_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_snat_options_port_start_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_snat_options_port_start_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_snat_options_port_end_edit
* 
* Edit database object callback
* Path: /iptables/rule/snat-options/port-end
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_snat_options_port_end_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_snat_options_port_end_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_snat_options_port_end_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_snat_options_edit
* 
* Edit database object callback
* Path: /iptables/rule/snat-options
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_snat_options_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_snat_options_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_snat_options_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_dnat_options_ip_edit
* 
* Edit database object callback
* Path: /iptables/rule/dnat-options/ip
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_dnat_options_ip_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_dnat_options_ip_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_dnat_options_ip_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_dnat_options_ip_end_edit
* 
* Edit database object callback
* Path: /iptables/rule/dnat-options/ip-end
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_dnat_options_ip_end_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_dnat_options_ip_end_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_dnat_options_ip_end_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_dnat_options_port_start_edit
* 
* Edit database object callback
* Path: /iptables/rule/dnat-options/port-start
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_dnat_options_port_start_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_dnat_options_port_start_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_dnat_options_port_start_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_dnat_options_port_end_edit
* 
* Edit database object callback
* Path: /iptables/rule/dnat-options/port-end
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_dnat_options_port_end_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_dnat_options_port_end_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_dnat_options_port_end_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_dnat_options_edit
* 
* Edit database object callback
* Path: /iptables/rule/dnat-options
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_dnat_options_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_dnat_options_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_dnat_options_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_rule_edit
* 
* Edit database object callback
* Path: /iptables/rule
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_rule_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_rule_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
    {
	//	printf("****    No of children: %i\n", val_child_cnt(newval));
		char cmd[512]; //The command to be run
		char tmpcmd[512]; //Var to temporary hold the command
		strcpy (cmd,"iptables "); //The beginning of the command to be run...
		val_value_t *tmpval; //Will hold the data node that we're processing each time

		//Find rule entry number
		tmpval = val_match_child(newval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("entryno"));
		if (tmpval != NULL) {
			if (VAL_INT(tmpval) == 1) {
				printf("\n****    First rule. Flashing iptables\n");
				printf("****    Would run command: iptables -F\n");
				//runsystem("iptables -F"); //Send command for running
			}
			printf("****    Rule No: %i\n", VAL_INT(tmpval));
		}

		//***   Parse all settings for the current rule   ***

		//Get table
		tmpval = val_match_child(newval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("table")); //Search for element
		if (tmpval != NULL) {
			//Get the element value:
			sprintf(tmpcmd, "-t %s ", VAL_STRING(val_get_first_child(tmpval)));
		  	strcat(cmd,tmpcmd); //Append the new part to the command
		}

		//Get append-to chain
		tmpval = val_match_child(newval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("appendto")); //Search for element
		if (tmpval != NULL) {
			//Get the element value:
			sprintf(tmpcmd, "-A %s ", VAL_STRING(val_get_first_child(tmpval)));
		  	strcat(cmd,tmpcmd); //Append the new part to the command
		}

		//Get protocol
		tmpval = val_match_child(newval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("protocol")); //Search for element
		if (tmpval != NULL) {
			//First check if second element ("NOT") is enabled:
			if (VAL_BOOL(val_get_next_child(val_get_first_child(tmpval))) == TRUE)
				strcat(cmd, "! "); //Add an inversion "!" to the command
			//Get the element value:
			sprintf(tmpcmd, "-p %s ", VAL_STRING(val_get_first_child(tmpval)));
		  	strcat(cmd,tmpcmd); //Append the new part to the command
		}

		//Get source IP
		tmpval = val_match_child(newval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("source-ip")); //Search for element
		if (tmpval != NULL) {
			//First check if second element ("NOT") is enabled:
			if (VAL_BOOL(val_get_next_child(val_get_first_child(tmpval))) == TRUE)
				strcat(cmd, "! "); //Add an inversion "!" to the command
			//Get the element value:
			sprintf(tmpcmd, "-s %s ", VAL_STRING(val_get_first_child(tmpval)));
		  	strcat(cmd,tmpcmd); //Append the new part to the command
		}


		//Get destination IP
		tmpval = val_match_child(newval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("dest-ip")); //Search for element
		if (tmpval != NULL) {
			//First check if second element ("NOT") is enabled:
			if (VAL_BOOL(val_get_next_child(val_get_first_child(tmpval))) == TRUE)
				strcat(cmd, "! "); //Add an inversion "!" to the command
			//Get the element value:
			sprintf(tmpcmd, "-d %s ", VAL_STRING(val_get_first_child(tmpval)));
		  	strcat(cmd,tmpcmd); //Append the new part to the command
		}

		//Get input interface
		tmpval = val_match_child(newval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("input-interface")); //Search for element
		if (tmpval != NULL) {
			//First check if second element ("NOT") is enabled:
			if (VAL_BOOL(val_get_next_child(val_get_first_child(tmpval))) == TRUE)
				strcat(cmd, "! "); //Add an inversion "!" to the command
			//Get the element value:
			sprintf(tmpcmd, "-i %s ", VAL_STRING(val_get_first_child(tmpval)));
		  	strcat(cmd,tmpcmd); //Append the new part to the command
		}

		//Get ouput interface
		tmpval = val_match_child(newval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("output-interface")); //Search for element
		if (tmpval != NULL) {
			//First check if second element ("NOT") is enabled:
			if (VAL_BOOL(val_get_next_child(val_get_first_child(tmpval))) == TRUE)
				strcat(cmd, "! "); //Add an inversion "!" to the command
			//Get the element value:
			sprintf(tmpcmd, "-o %s ", VAL_STRING(val_get_first_child(tmpval)));
		  	strcat(cmd,tmpcmd); //Append the new part to the command
		}

		//Get module
		tmpval = val_match_child(newval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("module")); //Search for element
		if (tmpval != NULL) {

				//Get the element value:
				sprintf(tmpcmd, "-m %s ", VAL_STRING(val_get_first_child(tmpval)));
		  		strcat(cmd,tmpcmd); //Append the new part to the command

		}

		//Get mark options
		tmpval = val_match_child(newval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("mark-options")); //Search for element
		if (tmpval != NULL) {
			//First check if second element ("NOT") is enabled:
			if (VAL_BOOL(val_get_next_child(val_get_first_child(tmpval))) == TRUE)
				strcat(cmd, "! "); //Add an inversion "!" to the command
			//Get the element value:
			sprintf(tmpcmd, "--mark %i ", VAL_INT(val_get_first_child(tmpval)));
		  	strcat(cmd,tmpcmd); //Append the new part to the command
		}

		//Get connmark-options
		tmpval = val_match_child(newval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("connmark-options")); //Search for element
		if (tmpval != NULL) {
			//Get the element value:
			sprintf(tmpcmd, "--%s ", VAL_STRING(val_get_first_child(tmpval)));
		  	strcat(cmd,tmpcmd); //Append the new part to the command
		}

		//Get state-options
		tmpval = val_match_child(newval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("state-options")); //Search for element
		if (tmpval != NULL) {
			//First check if second element ("NOT") is enabled:
			if (VAL_BOOL(val_get_next_child(val_get_first_child(tmpval))) == TRUE)
				strcat(cmd, "! "); //Add an inversion "!" to the command
			//Get the element value:
			sprintf(tmpcmd, "--state %s ", VAL_STRING(val_get_first_child(tmpval)));
		  	strcat(cmd,tmpcmd); //Append the new part to the command
		}

		//Get source port
		tmpval = val_match_child(newval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("source-port")); //Search for element
		if (tmpval != NULL) {
			//First check if second element ("NOT") is enabled:
			if (VAL_BOOL(val_get_next_child(val_get_first_child(tmpval))) == TRUE)
				strcat(cmd, "! "); //Add an inversion "!" to the command
			//Get the element value:
			sprintf(tmpcmd, "--sport %i ", VAL_INT(val_get_first_child(tmpval)));
		  	strcat(cmd,tmpcmd); //Append the new part to the command
		}

		//Get destination port
		tmpval = val_match_child(newval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("destination-port")); //Search for element
		if (tmpval != NULL) {
			//First check if second element ("NOT") is enabled:
			if (VAL_BOOL(val_get_next_child(val_get_first_child(tmpval))) == TRUE)
				strcat(cmd, "! "); //Add an inversion "!" to the command
			//Get the element value:
			sprintf(tmpcmd, "--dport %i ", VAL_INT(val_get_first_child(tmpval)));
		  	strcat(cmd,tmpcmd); //Append the new part to the command
		}

		//Get jump destination
		tmpval = val_match_child(newval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("jump")); //Search for element
		if (tmpval != NULL) {
			//Get the element value:
			sprintf(tmpcmd, "-j %s ", VAL_STRING(val_get_first_child(tmpval)));
		  	strcat(cmd,tmpcmd); //Append the new part to the command
		}

		//Get set-mark-option
		tmpval = val_match_child(newval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("set-mark-option")); //Search for element
		if (tmpval != NULL) {
			//Get the element value:
			sprintf(tmpcmd, "--set-mark %i ", VAL_INT(tmpval));
		  	strcat(cmd,tmpcmd); //Append the new part to the command
		}

		//Get snat-options
		tmpval = val_match_child(newval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("snat-options")); //Search for element
		if (tmpval != NULL) {
			val_value_t *tmpleaf; //Will hold the data node that we're processing each time
			strcat(cmd, "--to-source ");

			tmpleaf = val_match_child(tmpval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("ip")); //Search for leaf
			if (tmpleaf != NULL) {
				sprintf(tmpcmd, "%s", VAL_STRING(tmpleaf));
			  	strcat(cmd,tmpcmd); //Append the new part to the command
			}

			tmpleaf = val_match_child(tmpval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("ip-end")); //Search for leaf
			if (tmpleaf != NULL) {
				sprintf(tmpcmd, "-%s", VAL_STRING(tmpleaf));
			  	strcat(cmd,tmpcmd); //Append the new part to the command
			}

			tmpleaf = val_match_child(tmpval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("port-start")); //Search for leaf
			if (tmpleaf != NULL) {
				sprintf(tmpcmd, ":%i", VAL_INT(tmpleaf));
		  		strcat(cmd,tmpcmd); //Append the new part to the command
			}

			tmpleaf = val_match_child(tmpval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("port-end")); //Search for leaf
			if (tmpleaf != NULL) {
				sprintf(tmpcmd, "-%i ", VAL_INT(tmpleaf));
		  		strcat(cmd,tmpcmd); //Append the new part to the command
			}
		}

		//Get dnat-options
		tmpval = val_match_child(newval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("dnat-options")); //Search for element
		if (tmpval != NULL) {
			val_value_t *tmpleaf; //Will hold the data node that we're processing each time
			strcat(cmd, "--to-destination ");

			tmpleaf = val_match_child(tmpval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("ip")); //Search for leaf
			if (tmpleaf != NULL) {
				sprintf(tmpcmd, "%s", VAL_STRING(tmpleaf));
			  	strcat(cmd,tmpcmd); //Append the new part to the command
			}

			tmpleaf = val_match_child(tmpval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("ip-end")); //Search for leaf
			if (tmpleaf != NULL) {
				sprintf(tmpcmd, "-%s", VAL_STRING(tmpleaf));
			  	strcat(cmd,tmpcmd); //Append the new part to the command
			}

			tmpleaf = val_match_child(tmpval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("port-start")); //Search for leaf
			if (tmpleaf != NULL) {
				sprintf(tmpcmd, ":%i", VAL_INT(tmpleaf));
		  		strcat(cmd,tmpcmd); //Append the new part to the command
			}

			tmpleaf = val_match_child(tmpval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("port-end")); //Search for leaf
			if (tmpleaf != NULL) {
				sprintf(tmpcmd, "-%i ", VAL_INT(tmpleaf));
		  		strcat(cmd,tmpcmd); //Append the new part to the command
			}
		  	strcat(cmd," "); //Append the new part to the command
		}

/* BACKUP
		//Get dnat-options
		tmpval = val_match_child(newval, xmlCharStrdup("cit-iptables"), xmlCharStrdup("dnat-options")); //Search for element
		printf("****    newval No of children: %i\n", val_child_cnt(newval));
		printf("**** bet prints\n");
		if (tmpval != NULL) printf("*** tmpval not null\n");
		else printf("*** tmpval  null\n");
//		printf("****    tmpval No of children: %i\n", val_child_cnt(tmpval));
		if (tmpval != NULL) {
//		if (val_child_cnt(tmpval) != 0) {
			printf("**** inside if\n");
			val_value_t *tmpleaf; //Will hold the data node that we're processing each time
			strcat(cmd, "--to-destination ");
			tmpleaf = val_get_first_child(tmpval);
			printf("****    tmpleaf No of children: %i\n", val_child_cnt(tmpleaf));
			if (val_child_cnt(tmpleaf) != 0) {
				sprintf(tmpcmd, "%s", VAL_STRING(tmpleaf));
			  	strcat(cmd,tmpcmd); //Append the new part to the command

			}
			tmpleaf = val_get_next_child(tmpleaf);
			if (tmpleaf != NULL)
			if (val_child_cnt(tmpleaf) != 0) {
				sprintf(tmpcmd, "-%s", VAL_STRING(tmpleaf));
			  	strcat(cmd,tmpcmd); //Append the new part to the command

			}printf("bet iffsss\n");
			tmpleaf = val_get_next_child(tmpleaf);

			if (tmpleaf != NULL)
			if (val_child_cnt(tmpleaf) != 0) {
				sprintf(tmpcmd, ":%i", VAL_INT(tmpleaf));
		  		strcat(cmd,tmpcmd); //Append the new part to the command
			}
			tmpleaf = val_get_next_child(tmpleaf);
			if (tmpleaf != NULL)
			if (val_child_cnt(tmpleaf) != 0) {
				sprintf(tmpcmd, "-%i ", VAL_INT(tmpleaf));
		  		strcat(cmd,tmpcmd); //Append the new part to the command
			}
		  	strcat(cmd," "); //Append the new part to the command
		}
*/



		printf("****    Running command: %s\n", cmd);
		runsystem(cmd); //Send command for running

        	/* device instrumentation done here */
        	switch (editop) {
        	case OP_EDITOP_LOAD:
        	    break;
        	case OP_EDITOP_MERGE:
        	    break;
        	case OP_EDITOP_REPLACE:
        	    break;
        	case OP_EDITOP_CREATE:
        	    break;
        	case OP_EDITOP_DELETE:
        	    break;
        	default:
        	    res = SET_ERROR(ERR_INTERNAL_VAL);
        	}
	}
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_rule_edit */


/********************************************************************
* FUNCTION cit_iptables_iptables_edit
* 
* Edit database object callback
* Path: /iptables
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cit_iptables_iptables_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter cit_iptables_iptables_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }

        if (res == NO_ERR) {
            res = agt_check_cache(&iptables_val, newval, curval, editop);
        }
        
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* cit_iptables_iptables_edit */


/********************************************************************
* FUNCTION y_cit_iptables_init
* 
* initialize the cit-iptables server instrumentation library
* 
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
* 
* RETURNS:
*     error status
********************************************************************/
status_t y_cit_iptables_init (
    const xmlChar *modname,
    const xmlChar *revision)
{
    status_t res = NO_ERR;
    agt_profile_t *agt_profile;

    y_cit_iptables_init_static_vars();

    /* change if custom handling done */
    if (xml_strcmp(modname, y_cit_iptables_M_cit_iptables)) {
        return ERR_NCX_UNKNOWN_MODULE;
    }

    if (revision && xml_strcmp(revision, y_cit_iptables_R_cit_iptables)) {
        return ERR_NCX_WRONG_VERSION;
    }

    agt_profile = agt_get_profile();

    res = ncxmod_load_module(
        y_cit_iptables_M_cit_iptables,
        y_cit_iptables_R_cit_iptables,
        &agt_profile->agt_savedevQ,
        &cit_iptables_mod);
    if (res != NO_ERR) {
        return res;
    }

    iptables_obj = ncx_find_object(
        cit_iptables_mod,
        y_cit_iptables_N_iptables);
    if (cit_iptables_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    
    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/appendto",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_appendto_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/appendto/appendto",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_appendto_appendto_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/connmark-options",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_connmark_options_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/connmark-options/connmark-options",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_connmark_options_connmark_options_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/dest-ip",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_dest_ip_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/dest-ip/ip",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_dest_ip_ip_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/dest-ip/not",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_dest_ip_not_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/destination-port",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_destination_port_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/destination-port/not",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_destination_port_not_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/destination-port/port",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_destination_port_port_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/dnat-options",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_dnat_options_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/dnat-options/ip",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_dnat_options_ip_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/dnat-options/ip-end",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_dnat_options_ip_end_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/dnat-options/port-end",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_dnat_options_port_end_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/dnat-options/port-start",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_dnat_options_port_start_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/entryno",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_entryno_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/input-interface",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_input_interface_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/input-interface/interface",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_input_interface_interface_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/input-interface/not",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_input_interface_not_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/jump",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_jump_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/jump/jump",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_jump_jump_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/mark-options",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_mark_options_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/mark-options/mark",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_mark_options_mark_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/mark-options/not",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_mark_options_not_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/module",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_module_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/module/module",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_module_module_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/output-interface",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_output_interface_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/output-interface/interface",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_output_interface_interface_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/output-interface/not",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_output_interface_not_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/protocol",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_protocol_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/protocol/not",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_protocol_not_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/protocol/protocol",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_protocol_protocol_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/set-mark-option",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_set_mark_option_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/snat-options",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_snat_options_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/snat-options/ip",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_snat_options_ip_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/snat-options/ip-end",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_snat_options_ip_end_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/snat-options/port-end",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_snat_options_port_end_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/snat-options/port-start",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_snat_options_port_start_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/source-ip",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_source_ip_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/source-ip/ip",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_source_ip_ip_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/source-ip/not",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_source_ip_not_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/source-port",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_source_port_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/source-port/not",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_source_port_not_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/source-port/port",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_source_port_port_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/state-options",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_state_options_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/state-options/not",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_state_options_not_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/state-options/state",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_state_options_state_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/table",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_table_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/table/table",
        (const xmlChar *)"2012-01-12",
        cit_iptables_iptables_rule_table_table_edit);
    if (res != NO_ERR) {
        return res;
    }

    /* put your module initialization code here */
    
    return res;
} /* y_cit_iptables_init */


/********************************************************************
* FUNCTION y_cit_iptables_init2
* 
* SIL init phase 2: non-config data structures
* Called after running config is loaded
* 
* RETURNS:
*     error status
********************************************************************/
status_t y_cit_iptables_init2 (void)
{
    status_t res = NO_ERR;

    iptables_val = agt_init_cache(
        y_cit_iptables_M_cit_iptables,
        y_cit_iptables_N_iptables,
        &res);
    if (res != NO_ERR) {
        return res;
    }

    /* put your init2 code here */

    return res;
} /* y_cit_iptables_init2 */


/********************************************************************
* FUNCTION y_cit_iptables_cleanup
*    cleanup the server instrumentation library
* 
********************************************************************/
void y_cit_iptables_cleanup (void)
{
    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/appendto");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/appendto/appendto");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/connmark-options");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/connmark-options/connmark-options");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/dest-ip");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/dest-ip/ip");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/dest-ip/not");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/destination-port");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/destination-port/not");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/destination-port/port");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/dnat-options");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/dnat-options/ip");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/dnat-options/ip-end");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/dnat-options/port-end");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/dnat-options/port-start");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/entryno");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/input-interface");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/input-interface/interface");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/input-interface/not");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/jump");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/jump/jump");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/mark-options");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/mark-options/mark");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/mark-options/not");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/module");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/module/module");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/output-interface");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/output-interface/interface");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/output-interface/not");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/protocol");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/protocol/not");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/protocol/protocol");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/set-mark-option");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/snat-options");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/snat-options/ip");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/snat-options/ip-end");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/snat-options/port-end");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/snat-options/port-start");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/source-ip");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/source-ip/ip");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/source-ip/not");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/source-port");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/source-port/not");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/source-port/port");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/state-options");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/state-options/not");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/state-options/state");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/table");

    agt_cb_unregister_callbacks(
        y_cit_iptables_M_cit_iptables,
        (const xmlChar *)"/iptables/rule/table/table");

    /* put your cleanup code here */
    
} /* y_cit_iptables_cleanup */

/* END cit_iptables.c */
